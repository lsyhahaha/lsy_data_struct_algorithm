#### 10-28

#### [869. 重新排序得到 2 的幂](https://leetcode-cn.com/problems/reordered-power-of-2/)

##### ①暴力（模拟算法）

给一个正整数n，如何生成这些数字的重新排序的得到的数字？

##### ②预处理+哈希表（O（logN））

时间复杂度：对于一个数N，统计没位数出现的次数，基本操作数即为N的位数，即为log(N)；

```python
# mine
class Solution(object):
    def reorderedPowerOf2(self, n):
        """
        :type n: int
        :rtype: bool
        """
        # 预处理
        alist = []
        for i in range(30):
            set = dict()
            for s in str(2 ** i):
                # print(s)
                if s in set.keys():
                    set[s] = set[s] + 1
                else:
                    set[s] = 1
            alist.append(set)
        # print(alist)
		
        # 对输入的数同上哈希统计
        ret = dict()
        for s in str(n):
            if s in ret.keys():
                ret[s] = ret[s] + 1
            else:
                ret[s] = 1

        # print(ret)

        return ret in alist

a = Solution()
print(a.reorderedPowerOf2(1521))

# official 
def countDigits(n: int) -> Tuple[int]:
    cnt = [0] * 10
    while n:
        cnt[n % 10] += 1
        n //= 10
    return tuple(cnt)

powerOf2Digits = {countDigits(1 << i) for i in range(30)}

class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        return countDigits(n) in powerOf2Digits
```

#### 相关题：[231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)

